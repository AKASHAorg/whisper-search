{"version":3,"sources":["../../src/construct-index.js"],"names":["runService","getHash","ipfsHashChunks","web3","toUtf8","watcher","contracts","blockNumber","cb","blockNr","filter","fromBlock","toBlock","objects","entries","Publish","get","err","data","setTimeout","index","factory","Class","rIndex","getIpfs","hash","entryId","response","title","body","getInstance","api","then","resp","findLinks","length","multihash","final","catch","console","log","finally","found","search","query","AND","on","score","push","eth","getBlockNumber","nr","i","save","getEntry","call","args","toString","e","d","entryIpfs","resource","ipfsHash"],"mappings":"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","file":"construct-index.js","sourcesContent":["import contracts from '@akashaproject/contracts.js';\nimport { source, getIndex } from './indexModel';\nimport { getWeb3, BLOCK_INTERVAL } from './services';\nimport { IpfsConnector } from '@akashaproject/ipfs-connector';\n\nconst getHash = (ipfsHashChunks, web3) => {\n  return web3.toUtf8(ipfsHashChunks[0]) +\n    web3.toUtf8(ipfsHashChunks[1]);\n};\n\nconst watcher = (contracts, blockNumber, cb) => {\n  const blockNr = (blockNumber > BLOCK_INTERVAL) ? (blockNumber - BLOCK_INTERVAL) : 0;\n  const filter = { fromBlock: blockNr, toBlock: blockNumber };\n  contracts.objects.entries.Publish({}, filter).get((err, data) => {\n    cb(err, { data, blockNr });\n    if (blockNumber !== 0) {\n      return setTimeout(() => watcher(contracts, blockNr, cb), 100);\n    }\n  });\n};\n\n\n\nexport default function runService () {\n  let index;\n  const web3 = getWeb3();\n  const factory = new contracts.Class(web3);\n  getIndex((err, rIndex) => {\n    if (err) {\n      throw err;\n    }\n    index = rIndex;\n  });\n\n  const getIpfs = (hash, entryId) => {\n    let response = { title: '', body: '', entryId: entryId };\n    return IpfsConnector.getInstance().api.get(hash)\n      .then((resp) => {\n        response.title = resp.title;\n        return IpfsConnector.getInstance().api.findLinks(hash, ['excerpt']);\n      })\n      .then((resp) => {\n        if (resp.length) {\n          return IpfsConnector.getInstance().api.get(resp[0].multihash)\n        }\n      })\n      .then((final) => {\n        response.body = final;\n      })\n      .catch((err) => {\n        console.log('ERROR ', { hash, entryId }, err);\n      })\n      .finally(() => {\n        let found = false;\n        index.search({ query: { AND: { title: [response.title], body: [response.body] } } })\n          .on('data', function (data) {\n            if (data.score > 1) {\n              found = true;\n            }\n          }).on('end', function () {\n          if (!found) {\n            console.log('PUSHING', response);\n            source.push(response);\n          }\n        });\n      });\n  };\n\n  web3.eth.getBlockNumber((err, nr) => {\n    return watcher(factory, nr, (err, found) => {\n      console.log(found);\n      let i =0 ;\n      const save = () => {\n        factory.objects.entries.getEntry.call((found.data[i].args.entryId).toString(), (e, d) => {\n          const entryIpfs = d[2];\n          const resource = getHash(entryIpfs);\n          let found = false;\n          index.search({ query: { AND: { ipfsHash: [resource] } } }).on('data', function () {\n            found = true;\n          }).on('end', function () {\n            if (!found) {\n              source.push({ ipfsHash: resource });\n            }\n\n            return getIpfs(resource, (found.data[i].args.entryId).toString()).then(() => {\n              i++ ;\n              if(i<found.length){\n                save();\n              }else{\n                source.push(null);\n              }\n            });\n          });\n        });\n      }\n    });\n  });\n\n}\n"]}